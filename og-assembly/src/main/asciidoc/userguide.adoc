= Object Generator
v{display-version}, {build-date}
:toc: right
:sectlinks:
:sectanchors:
:numbered:
:source-highlighter: highlightjs
:icons: font
:sampledir: ../resources/conf/sample

== Introduction
Object Generator (OG) is an HTTP object storage load tool designed for system
level stress, stability and performance testing. OG supports several common
object storage APIs including S3 and OpenStack Swift.

== Installation

=== Minimum Requirements
|===
|Component|Configuration

|CPU
|Dual Core

|Memory
|4GB system; 2GB available

|Free Disk Space
|20GB for logging

|Operating System
|Modern Linux OS*

|Java Version
|Java 7
|===

NOTE: *OG has been tested on Ubuntu 14.04, but any modern linux OS should work.

=== Distribution
OG is distributed as a _tar.gz_ archive. To install, simply unpack the archive
in a directory of your choice.

[source, bash, subs="attributes"]
----
~$ tar -zxf og-{display-version}.tar.gz
----

== Project Layout
The OG project consists of the following files and directories:

[source, bash]
----
~$ tree
├── conf // <1>
│   ├── object-file-log4j2.xml
│   ├── og-log4j2.xml // <2>
│   └── sample // <3>
├── docs
│   └── userguide.html <4>
├── lib // <5>
├── log // <6>
├── object // <7>
├── object-file // <8>
└── og // <9>
----
<1> Configuration directory. Includes logging configuration and sample test configurations
<2> OG logging configuration
<3> Sample test configurations
<4> This user guide
<5> Third party library dependencies
<6> Default log location
<7> Default object file location
<8> Auxiliary object file management script
<9> Primary OG load driver script

=== Invocation
OG is a command line load tool which is controlled via the _og_ shell
script.

.OG Help
[source, bash]
----
$ ./og --help
Usage: og [<og_config>] [-v|--version] [-h|--help]
  [<og_config>]
        A relative or absolute path to an og json configuration file

  [-v|--version]
        Prints the og version and exits

  [-h|--help]
        Prints this help and exits
----

To run a test with OG, call the _og_ shell script with a relative or absolute
path to a configuration file:

.Basic Invocation
[source, bash, subs="attributes"]
----
$ ./og conf/sample/simple-s3.json
-------------------------------------------------------------------------------
Object Generator ({display-version})
-------------------------------------------------------------------------------
Configuring...
Configured.
Test Running...
Test Completed.
-------------------------------------------------------------------------------
Summary
-------------------------------------------------------------------------------
Start: 21/Jan/2016:23:20:31 -0600
End: 21/Jan/2016:23:20:32 -0600
Runtime: 0.29 Seconds
Operations: 31

[WRITE]
Operations: 31
Bytes: 310.00
Throughput: 1.07 KB/s
OPS: 107.27
Status Codes:
201: 31

[READ]
Operations: 0
Bytes: 0.00
Throughput: 0.00 B/s
OPS: 0.00
Status Codes:
N/A

[DELETE]
Operations: 0
Bytes: 0.00
Throughput: 0.00 B/s
OPS: 0.00
Status Codes:
N/A


$
----

== Configuration
OG is configured via a json formatted test configuration file. This file
controls which object storage API, request mix, file size mix and concurrency
to use, and more. To jump straight to complete examples, see <<Examples>>.
Otherwise, the following sections describe OG configuration in detail.

[[cref1]]
*_Note that the weights used for selection of choices are strictly weights. They are not
       percentages._*

=== Storage
OG supports the following Storage APIs:

|===
|Storage API

|S3

|OpenStack Swift

|Cleversafe SOH

|WebDAV
|===

Write, Read, Metadata, and Delete operations are supported for each of the supported
Storage APIs. In addition, Overwrite is supported for S3 and OpenStack Swift.
Storage API is configured via the _api_ key:

.S3 API Example
[source, json]
----
"api": "s3"
----

=== Authentication
OG supports the following authentication configurations:

|===
|Authentication

|Anonymous

|Basic Auth

|AWS Auth V2

|AWS Auth V4

|Keystone

|IBM Cloud IAM
|===

Authentication is configured via an _authentication_ block of the test
configuration:

[source, json]
----
"authentication": {}
----

Authentication credentials can be provided directly in the OG json
config file for a single user. The credentials can also be provided
in a file for multiple users. Please refer to <<credential_file_format>>


==== Anonymous
Anonymous authentication is the default authentication configuration. It
is configured by omitting the _authentication_ block from the test
configuration. It can also be explicitly configured.

.None Auth Example
[source, json]
----
"authentication": {
  "type": "none"
}
----

==== Basic Auth
Basic authentication uses base64 encoding to encode username and password
credentials into an authorization request header that is sent to the target
server.

When using basic auth for openstack swift implementation on a dsnet stass based release, storage account field is needed.
The given account is used in openstack swift API url.

.Basic Auth with Single User Example
[source, json]
----
"authentication": {
  "type": "basic",
  "username": "my_user",
  "password": "my_password"
}
----

.Basic Auth with Single User with OpenStack swift API
[source, json]
----
"authentication": {
  "type": "basic",
  "username": "my_user",
  "password": "my_password",
  "account": "swiftaccountX"
}
----
.Basic Auth with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "basic",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json"
}
----

==== AWS Auth V2
AWS Auth V2 authentication is an S3 authentication scheme which uses an access
key and secret key for credentials. These keys are configured in OG via
_username_ and _password_ keys, respectively.

.AWS Auth V2 Example
[source, json]
----
"authentication": {
  "type": "awsv2",
  "username": "AKIAIOSFODNN74SFNMK",
  "password": "nJalrUUFklNEMI/K7MDENG/gPwRfiCYXY73DER"
}
----

.AWS Auth V2 with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "awsv2",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json"
}
----

NOTE: The current AWS Auth V2 implementation does not support virtual host
addressing. See <<Virtual Host>> for more details.

==== AWS Auth V4
AWS Auth V4 authentication is an S3 authentication scheme which uses an access
key and secret key for credentials. These keys are configured in OG via
_username_ and _password_ keys, respectively.

With AWS Auth V4, the body of the request is included in the signing process.
AWS Auth V4 requests can either sign the entire request body up front, which
requires reading the entire contents first, or sign the body in chunks as the
request is sent. Chunked signing is configured via the _aws_chunked_ key.

NOTE: For more information about AWS V4 signing, see: http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html[Signing and Authenticating REST Requests]

.AWS Auth V4 With Signing The Entire Request Example
[source, json]
----
"authentication": {
  "type": "awsv4",
  "username": "AKIAIOSFODNN74SFNMK",
  "password": "nJalrUUFklNEMI/K7MDENG/gPwRfiCYXY73DER"
}
----

.AWS Auth V4  With Signing The Entire Request with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "awsv4",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json"
}
----

.AWS Auth V4 With Chunked Signing Example
[source, json]
----
"authentication": {
  "type": "awsv4",
  "username": "AKIAIOSFODNN74SFNMK",
  "password": "nJalrUUFklNEMI/K7MDENG/gPwRfiCYXY73DER",
  "aws_chunked": true
}
----

.AWS Auth V4 With Chunked Signing with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "awsv4",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json",
  "aws_chunked": true
}
----

Because the signing process for V4 requests is CPU intensive, OG additionally
provides an optional mechanism for caching a portion of the signature process,
which reduces the CPU load on the load tool, which in turn reduces the risk of
the load tool as a performance bottleneck when executing V4 performance tests.
To enable caching, OG must be configured to write objects with all zeroes for
data (See <<Data>>) so that the signatures are cacheable. Then, to enable the
cache, configure the cache size via _aws_cache_size_.

.AWS Auth V4 With Signature Caching
[source, json]
----
"authentication": {
  "type": "awsv4",
  "username": "AKIAIOSFODNN74SFNMK",
  "password": "nJalrUUFklNEMI/K7MDENG/gPwRfiCYXY73DER",
  "aws_cache_size": 10000
}
----

.AWS Auth V4 With Signature Caching with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "awsv4",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json",
  "aws_cache_size": 10000
}
----

==== Keystone
Keystone authentication is an OpenStack Swift authentication scheme which
typically relies on an external Keystone server to generate an authentication
token for use by object storage requests. Keystone support in OG does not
include token lookup via an external Keystone server. Rather, OG requires a
keystone token be manually generated prior to test start.

When using keystone auth for openstack swift implementation on a dsnet stass based release, storage account field is needed.
The given account is used in openstack swift API url.

.Keystone Example
[source, json]
----
"authentication": {
  "type": "keystone",
  "keystone_token": "7fe2cd9ee6384a1894a43878d3e52daf"
}
----

.Keystone Example for Openstack API, stass based release
[source, json]
----
"authentication": {
  "type": "keystone",
  "keystone_token": "7fe2cd9ee6384a1894a43878d3e52daf",
  "account": "swiftaccountX"
}
----

.Keystone with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "keystone",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json"
}
----

==== IBM Cloud IAM
IBM Cloud authentication relies on external centrally-managed integrated services
to provide account management, authentication, and policy decision making.
Access to storage resources is provided based on requestor's access token
that is generated by token service using IBM BlueMix account ID and API key.
Cloud IAM support in OG does not include ID and key management and expects
provisioned access tokens that will remain valid during a test. 

.IBM Cloud IAM Example
[source, json]
----
"authentication": {
  "type": "IAM",
  "iam_token": "Bearer eyJraWQiOiIxODQ5MjY4NjQ4IiwiYWxnIjoiUlMyNTYifQ==.eyJpZCI6IjY2M2IzYjRmNDk5ZS0yZTI5LTc0YTQtMTEwZC1hOTNjMDYyNyIsImlhbV9pZCI6IjY2M2IzYjRmNDk5ZS0yZTI5LTc0YTQtMTEwZC1hOTNjMDYyNyIsImlkZW50aWZpZXIiOiI2NjNiM2I0ZjQ5OWUtMmUyOS03NGE0LTExMGQtYTkzYzA2MjciLCJzdWIiOiI2NjNiM2I0ZjQ5OWUtMmUyOS03NGE0LTExMGQtYTkzYzA2MjdAdXMuaWJtLmNvbSIsImFjY291bnQiOnsiYnNzIjoiOTk5OTkiLCJpbXMiOiI5OTk5OSJ9LCJtZmEiOnsiaW1zIjp0cnVlLCJic3MiOmZhbHNlfSwiaXNzIjoiaHR0cHM6Ly90ZXN0bGFidG9rZW5pc3N1ZXIuY2xldmVyc2FmZS5jb20vb2lkYy90b2tlbiIsImdyYW50X3R5cGUiOiJhcGlrZXkiLCJzY29wZSI6Im9wZW5pZCIsImNsaWVudF9pZCI6IjY2M2IzYjRmNDk5ZS0yZTI5LTc0YTQtMTEwZC1hOTNjMDYyN0B1cy5pYm0uY29tIiwiaWF0IjoxNTAyNDAxNjgzLCJleHAiOjE1MDI0MDUyODN9.eC4m6NWQmVKCe_Tfc_zpwOZyidyWQrV7SGLv3FYCo0hgRLlU1eO75_eslEt5DSU14Qju9imTKYmgrxYfdFVioEQWQMbbVxeG9evXytwnDNmCVaYTBNobyZvOZR1Yz4UwCoj4WXmXrpbPcq_Dt-MKn-EUQKH2GdpHTRGiMSoAuuL6NExgl9PeAFKCw3e0KF0TvOMJ5kLbPuli2q3FxF4z71E81357UoSPMPY9safrdb4PIvrrHJ021TG7KqTwd61x_l9uUocHUOWqgmV9hWKvtabkUhpkjFJ-ruH16esXhfNLFFflwi3yyl1aYwUD1NUVMTqTNdAGmo4LgBsR7mS_DQJhO2GpfDC2Ia9Mpo2QhNVwPk3k7cv3XABuM5CnnjTks_qEkavnL_wVtvuydECf_4r52RsK01goXAAru6RDeuyRAG6uK4s1w_Z6KuK74CG4R97dqi5hGyzRJfFOD3USqQnjbIJlK5tCwox1HqH4GBa4QuU5Sy7ZaacQYHerIArGmnD96lKfhgNLyRVv5jIN6GmdM4FYBRuprSbdWLqKsG0rrdCioXImAJ3v6HY4Xtr5BLUyyVOCxEhrGKgmPZEQ_YYT9s1js3i2grdTEpgiaVaPlYpY0WXj1PqODK_drDDrcn16tJzp2Q7l1wIQG-ESRV98ZPpfVwJygio5MhrwKCk="
}
----

.IBM Cloud IAM with Multiple Users Example
[source, json]
----
"authentication": {
  "type": "IAM",
  "credential_source": "file",
  "credential_file": "/var/log/og/credentials.json"
}
----

=== Host
Host is the target endpoint that the OG load tool communicates with to execute
object storage requests. A host can be either a host name or an IPv4 IP
address. OG supports single and multiple host configurations. For multiple
hosts, OG supports selection of a host for a given request via round robin,
random, or weighted random configurations. Host(s) are configured via the
_host_ key.

NOTE: When testing against a Cleversafe dsNet, the _host_ key refers to
Accesser hostnames or IP addresses.

.Single Host Example
[source, json]
----
"host": "s3.amazonaws.com"
----

.Multiple Host Round Robin Example
[source, json]
----
"host": {
  "selection": "roundrobin",
  "choices": ["10.129.100.100", "s3.amazonaws.com", "loadbalancer01.example.com"]
}
----

.Multiple Host Random Example
[source, json]
----
"host": {
  "selection": "random",
  "choices": ["10.129.100.100", "s3.amazonaws.com"]
}
----

.Multiple Host Weighted Random Example
[source, json]
----
"host": {
  "selection": "random",
  "choices": [
    {
      "choice": "10.129.100.100",
      "weight": 1.0
    },
    {
      "choice": "s3.amazonaws.com",
      "weight": 2.0
    }
  ]
}
----
_<<cref1,See note about weights>>_.

=== Port
OG supports configuring the port that object storage requests are executed
against. Port configuration applies to all configured hosts. Port is
configured via the _port_ key.

.Port Example
[source, json]
----
"port": "8080"
----

=== Container
Container is the logical bucket that the OG load tool will write objects into.
OG supports single and multiple container configurations. For multiple
containers, OG supports selection of a container for a given request via round
robin or random configurations. With multiple containers, _prefix_,
_min_suffix_ and _max_suffix_ keys are used to produce a range of container
names. Container(s) are configured via the _container_ key. This key is available
at both the top level and operation level. The most common usage at the operation
level is for StaaS container creation.

NOTE: If writes are done using container suffixes, then all other operations
using these objects will need to use a prefix only or prefix+suffix with
the object configuration block.

NOTE: When testing against a Cleversafe dsNet, the _container_ key refers to
dsNet Vaults or StaaS containers.

.Single Container Example
[source, json]
----
"container": "my_container"
----

.Multiple Container Round Robin Example
[source, json]
----
"container": {
  "selection": "roundrobin",
  "prefix": "my_container",
  "min_suffix": 0,
  "max_suffix": 100
}
----

.Multiple Container Random Example
[source, json]
----
"container": {
  "selection": "random",
  "prefix": "my_container",
  "min_suffix": 0,
  "max_suffix": 100
}
----

=== Headers
Custom HTTP request headers can be added to every request that is executed.
Header values can be constant or dynamic. For dynamic header value
configuration, values can be selected via round robin, random or weighted
random. Headers are configured via the _headers_ key.

NOTE: Custom headers will be added to every request. To add custom headers
only for a specific operation type, see <<Operation Headers>>

.Headers Static Values Example
[source, json]
----
"headers": {
  "custom_key_01": "custom_value_01",
  "custom_key_02": "custom_value_02"
}
----

.Headers Random Dynamic Values Example
[source, json]
----
"headers": {
  "custom_key_01": {
    "selection": "random",
    "choices": ["custom_value_01", "custom_value_02", "custom_value_03"]
  },
  "custom_key_02": "custom_value_04"
}
----

.Headers Round Robin Dynamic Values Example
[source, json]
----
"headers": {
  "custom_key_01": {
    "selection": "roundrobin",
    "choices": ["custom_value_01", "custom_value_02", "custom_value_03"]
  },
  "custom_key_02": "custom_value_04"
}
----

.Headers Weighted Random Dynamic Values Example
[source, json]
----
"headers": {
  "custom_key_01": {
    "selection": "random",
    "choices": [
      {"choice": "custom_value_01", "weight": 2.0},
      {"choice": "custom_value_02", "weight": 7.0},
      {"choice": "custom_value_03", "weight": 5.0}
    ]
  },
  "custom_key_02": "custom_value_04"
}
----
_<<cref1,See note about weights>>_.

=== OG Operations ===

Write, Read, Metadata, Delete, and List operations are supported for all Object Storage APIs.

Write operation supports adding LegalHold and retention to the object.

Writecopy is only suppported for s3.

Overwrite is supported for S3 and OpenStack Swift.

Read operation supports range reads. A choice of ranges can be specified. Here is a sample.
----
  "read": {
    "weight": 0.5,
    "range": {
      "selection": "random",
      "choices": [
        {
          "choice": {
            "distribution": "uniform",
            "average": 1000,
            "average_unit": "bytes",
            "spread": 0,
            "spread_unit": "bytes"
          },
          "weight": 1
        }
      ]
    }
  }
----
If the range size is greater than the object size, the range is set to object size. Otherwise
a random range in the object is selected.

Write Legalhold operation will add a Legalhold to an existing object.

Delete Legalhold operation will remove Legalhold on an object.

Read Legalhold operation will list the legalholds on an object.

Extend Retention operation adds additional time to the existing retention time of the object.

Object Restore, Put and Get container lifecycle operations are supported for S3 only.

Container Create and Container List are supported for S3 only and the current dsnet implementation
requires the uri_root be set to "/".

Multipart Write is also only supported for S3.

Multidelete Operation is supported for S3. Currently when using this API, it is expected 
that the object file contains objects from only one container. Otherwise the objects 
from an _unintended bucket_ will be removed from the object management. object-file utility 
can be used to filter the objects for a specific vault.

Operation mix is configured via _write_, _overwrite_, _read_, _metadata_, _delete_, _list_,
_container_create_, _container_list_, _multipart_write_, _write_legalhold_, _read_legalhold_,
_delete_legalhold_, _extend_retention_, _object_restore, _put_container_lifecycle_,
_get_container_lifecycle_, delete_container_lifecycle,  _put_container_protection_, _get_container_protection_, 
_multi_delete_ keys respectively.

Each operation type is configured via a configuration block. E.g. for write:

[source, json]
----
"write": {}
----

The configuration block supports _weight_, _host_, _object_ and _header_ keys.

==== Operation Weight
The _weight_ configuration key determines the relative number of requests for
each operation type. _<<cref1,See note about weights>>_.

.Operation weights Example
The configuration below will produce two write operations for a single read operation.
[source, json]
----
"write": {"weight": 2.0},
"read": {"weight": 1.0},
"delete": {"weight": 0.0}
----

==== Operation Host
OG supports overriding the global host configuration for a particular operation
type. See <<Host>> for more details.

==== Operation Object
OG supports multiple object name configurations via the _object_ key:

[source, json]
----
"object": {}
----

Note that *object configuration property should be included under the Operation (write, read etc.) config*.
If the object block is defined at root level, it will not have any effect.

By default, OG will generate a unique, uuid-like object name for every write
request. Writecopy operation will select a random object name from objects which have already been written for source object.
By default, the destination object name will be a unique, uuid-like object name.
Overwrite, Read, Metadata, and Delete requests will select a random object name from
objects which have already been written. List will use a random object name as its starting
point and then provide the default number of entries for the associated API.
See <<Object Management>>.

To override this behavior, the _object_ configuration block can be configured
to include _selection_, _prefix_, _min_suffix_, _max_suffix_, and _osuffix_ keys. The _min_suffix_ and
_max_suffix_ define the range of a numeric suffix. Random
and round robin selection configuration is supported. The _osuffix_, if provided, is appended after
the numeric suffix.  The resulting object name will be of the form:

[source, bash]
----
<prefix><suffix><osuffix>
----

WARNING: Using custom object name configuration bypasses object management.
Object names written with a custom prefix and suffix will not be stored in the
object manager, for example.

CAUTION: The Cleversafe SOH Storage API does not support custom object names.
Instead, an auto-generated name is returned to the client after the object has
been written. Because of this, custom object name configuration should not be
configured in OG for use with the SOH API.

.Random Object Name Example
[source, json]
----
"object": {
  "selection": "random",
  "prefix": "my_object",
  "min_suffix": 0,
  "max_suffix": 100
}
----

.Round Robin Object Name Example
[source, json]
----
"object": {
  "selection": "roundrobin",
  "prefix": "my_object",
  "min_suffix": 0,
  "max_suffix": 100
}
----

.Round Robin Object Name with osuffix Example
[source, json]
----
"object": {
  "selection": "roundrobin",
  "prefix": "my_object",
  "min_suffix": 0,
  "max_suffix": 100,
  "osuffix": "test001"
}
----

==== Operation Headers
OG supports custom headers for a particular operation type. Headers configured
for an operation type override any custom headers which were configured
generally. See <<Headers>> for more details.

.Custom Headers For Write Requests Example
[source, json]
----
"write": {
  "headers": {
    "custom_key_01": "custom_value_01",
    "custom_key_02": "custom_value_02"
  }
}
----

==== Operation Query Parameters
OG supports custom query parameters for a particular operation. This is
currently supported only for the List operation.

.Custom Query For List Requests Example
[source, json]
----
"list": {
  "parameters": {
    "custom_key_01": "custom_value_01",
    "custom_key_02": "custom_value_02"
  }
}
----
For s3 bucket listing, add parameter list-type=2. Refer to AWS s3 bucket listing api documentation for additional details.

Additionally, for *list* operation, a new attribute weighted_parameters is added. This gives an ability to specify mutiple chocies
for the parameters values. For example, this can be used to specify multiple max-keys values.

.Weighted Query Parameters for List Operation.
[source, json]
----
"list": {
  "parameters": {
    "custom_key_01": "custom_value_01",
    "custom_key_02": "custom_value_02"
  }
  "weighted_parameters": {
    "max-keys": {
    "selection": "random",
      "choices": [
        {
          "weight": 2,
          "choice": 20
          },
          {
            "weight": 2,
            "choice": 100
          }
        ]
  }
}
----

==== Operation Container
OG supports the _container_ key at the operation level with some
caveats as noted in the Container section.

=== Operation Delimiter Character
OG Supports the _delimiter_ key at the operation level with operations _write_,
_multipart_write_ and _write_copy_ operations.
It is a weighted choice of delimiter characters that can be used for at the specified
position in the object name string.  See below for a sample.

Each choice can have list of delimiter characters. The selection can be random or round robin.

----
 "delimiter": {
    "selection": "random",
    "choices": [
      {
        "choice": {
          "delim_chars": [
            {
              "positions": [
                5,
                7
              ],
              "value": "a"
            },
            {
              "value": "b",
              "positions": [
                10
              ]
            }
          ]
        },
        "weight": 5
      },
      {
        "choice": {
          "delim_chars": [
            {
              "positions": [
                14
              ],
              "value": "b"
            }
          ]
        },
        "weight": 30
      }
    ]
  }
----


==== Operation Multipart Write
Multipart write supports an additional part size parameter so that the user
can define one or more part sizes as part of the object block to use in conjunction
with filesize. The default part size is 5MiB and part size is defined in bytes in the config
document.

.Example Multipart Write using Multiple Part Sizes
[source, json]
"multipart_write": {
    "upload": {
        "part_size": {
            "choices": [
                {
                    "choice": 5242880,
                    "weight": 1
                },
                {
                    "choice": 10242880,
                    "weight": 2
                }
            ],
            "selection": "random"
        },
        "parts_per_session": {
            "choices": [],
            "selection": "random"
        },
        "target_sessions": 1
    },
    "weight": 100
},

.Example Multipart Write using a Single Part Size
[source, json]
"multipart_write": {
        "weight": 1.0,
        "part_size": 5242880
}

Regarding the OG implementation of Multipart Write, there are some caveats. In the current
implementation, OG will send as many INITIATE requests as it can, up to the thread count, until
it receives an upload id response from one of the requests. At that point, it will begin
sending PART requests for in process multipart sequences in order of INITIATE request responses.
Once all parts are uploaded, a COMPLETE will be sent before any other PART or INITIATE requests are sent.

For example, in a 100 thread test, up to 100 INITIATE requests will be sent. Once one request
returns, it will begin sending parts for that request, up to 100 parts at a time. Once all those
parts are in process or finished, it will begin sending parts for the other requests.

==== Operation ServerSide Encryption with Client Provided Key
The uploaded object can be encrypted with server side encryption with client provided key. This can
be indicated by setting sse_c_source property to true. In case of PUT COPY operation, the target object
can be encrypted by setting sse_c_destination property to true.

OG uses predefined key for AES 256 encryption. This will be used as client encryption key unless
relevant headers are provided in the config. The relevant headers for this are:

* x-amz-server-side-encryption-customer-algorithm
* x-amz-server-side-encryption-customer-key
* x-amz-server-side-encryption-customer-key-MD5
* x-amz-copy-source-server-side-encryption-customer-algorithm
* x-amz-copy-source-server-side-encryption-customer-key
* x-amz-copy-source-server-side-encryption-customer-key-MD5

Please refer to AWS S3 API reference for further details about this header fields.

An example write_copy operation is show below:
----
  "write_copy": {
    "weight": 1.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "selection": "random",
      "min_suffix": -1,
      "max_suffix": -1
    },
      "sse_c_source": true,
      "sse_c_destination": true
  },
----

Refer to section <<operation_configuration>> in Appendix for further details about this configuration property.

==== Operation LegalHold
When Legalhold is set on the object, the object is protected and cannot be modified until
the legalhold is removed from the object.

If a legalhold prefix is specified, that will be used. Otherwise, the default prefix is
"LegalHold".  The percentage field indicates percent times the legal_hold operation is supplied.
The percentage value for write operation can be between 0 and 100. For write_legalhold and delete_legalhold operations
percentage must be 100.00.

----
    "legal_hold": {
      "legal_hold_prefix": "MyLegalHold",
      "percentage" : 50.00
    }
----

==== Operation write_legalhold

This operation is used to a legalhold to an existing object.

An example write_legalhold operation is listed below.
----
  "write_legalhold": {
    "weight": 100.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "selection": "random",
      "min_suffix": -1,
      "max_suffix": -1
    },
    "legal_hold": {
        "legal_hold_prefix": "",
        "percentage": 100.00
    }
  }
----

==== Operation Delete LegalHold
This operation is used to delete a legalhold on the object.

 An example delete_legalhold operation is listed below.
 ----
  "delete_legalhold": {
     "weight": 100.0,
     "object": {
       "prefix": "",
       "min_suffix": 0,
       "max_suffix": 9223372036854775807
     },
     "headers": {},
     "parameters": {},
     "body": "none",
     "container": {
       "selection": "random",
       "min_suffix": -1,
       "max_suffix": -1
     },
      "legal_hold": {
          "percentage": 100.00
     }
   }
 ----

==== Operation Read LegalHold
This operation returns the list of legalholds on the object.

An example read_legalhold operation is listed below.

----
  "read_legalhold": {
    "weight": 100.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "selection": "random",
      "min_suffix": -1,
      "max_suffix": -1
    }
  }
----




==== Operation Retention
Retention sets the time of expiry of an object while creating the object. This can be added to the *write* operation.
The object cannot be deleted until the retention time expires.

The expiry value of -1 is a special value. In this case, no retention is set. The object retention is set to the default
retention of the vault.

----
    "retention": {
      "selection": "random",
      "choices": [
        {
          "choice": {
            "expiry": 86400,
            "time_unit": "seconds"
          },
          "weight": 1.0
        }
      ]
    }
----


==== Operation Extend Retention
Retention configuration in the *Extend Retention operation* adds additional time to the expiry of an object. The object
 will be protected until the retention time expires.

The expiry value must be greater than 0. The new retention will be added to the existing retention period. The resulting
retention must be in the future time.

----
    "retention": {
      "selection": "random",
      "choices": [
        {
          "choice": {
            "expiry": 86400,
            "time_unit": "seconds"
          },
          "weight": 1.0
        }
      ]
    }
----

==== Operation Object Restore ====
Object Restore operation restores an object in the glacier storage state to active state.

----
    "object_restore": {
      "weight": 10,
      "object_restore_period": 1
    }
----

==== Operation Put Container Lifecycle Configuration ====
This operation adds a lifecycle configuration to the bucket. The new objects will transition to glacier state
after the specified number of days in archive_transition_period. The unit of archive_transition_period is days.

----
    "put_container_lifecycle": {
      "weight": 0,
      "archive_transition_period": 1
    }
----

==== Operation Get Container Lifecycle configuration ====
This operation retrieves the configured lifecycle configuration on the bucket.

----
    "get_container_lifecycle": {
      "weight": 0
    }
----

==== Operation Delete Container Lifecycle configuration ====
This operation deletes the configured lifecycle configuration on the bucket.

----
    "delete_container_lifecycle": {
      "weight": 0
    }
----

==== Operation Put Container Protection Configuration
This operation puts container protection configuration for the bucket. The input consists of container information,
default, minimum and maximum retention for the container. The time unit for the retention in days.

----
  "put_container_protection": {
    "weight": 50.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "prefix" : "pcontainer",
      "selection": "roundrobin",
      "min_suffix": 0,
      "max_suffix": 4
    },
    "container_minimum_retention": {
      "selection": "random",
        "choices": [
            {
                "choice": {
                    "expiry": 50,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 70,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 90,
                    "time_unit": "days"
                },
                "weight": 1.0
            }
        ]
   },
    "container_default_retention": {
      "selection": "random",
        "choices": [
            {
                "choice": {
                    "expiry": 200,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 250,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 245,
                    "time_unit": "days"
                },
                "weight": 1.0
            }
        ]
   },
    "container_maximum_retention": {
      "selection": "random",
        "choices": [
            {
                "choice": {
                    "expiry": 301,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 350,
                    "time_unit": "days"
                },
                "weight": 1.0
            },
            {
                "choice": {
                    "expiry": 400,
                    "time_unit": "days"
                },
                "weight": 1.0
            }
        ]
   }
  }
----

==== Operation Get Container Protection ====
The Get Container Protection operation retrieves the container protection details on the bucket.

----

  "get_container_protection": {
    "weight": 50.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "prefix" : "pcontainer",
      "selection": "random",
      "min_suffix": 0,
      "max_suffix": 4
    }
  },

----

==== Operation List configuration ====
This operation fetches the list of object names in the bucket. The general operation configuration
properties weight, headers, parameters, container are applicable to this operation.

*weighted_parameters* property is added in the list configuration. Now a weighted choice of
values can be specified for a single parameter.

----
  "list": {
    "weight": 0,
    "parameters": {},
    "weighted_parameters": {
          "max-keys": {
          "selection": "random",
          "choices": [
            {
              "choice": "100",
              "weight": 1.0
            },
            {
              "choice": "1000",
              "weight": 5.0
            },
          ]
       }
  }

----
list_max_keys has been added to supported weight choice of max_keys for the operation.
Random and round robin selection configuration is supported.
----
    "list_max_keys": {
      "selection": "random",
      "choices": [
          {
            "choice": "50",
            "weight": 1.0
          },
          {
            "choice": "100",
            "weight": 5.0
          },
          {
            "choice": "1000",
            "weight": 10.0
          }
      ]
    }
----

*list_session_config* property defines the type of list operations. A list session
is a set of related list requests. If this value is not specified, the default list_session_config
is used. The default list_session_config has random selection of UNCHAINED list requests with random
markers.

There are 2 types of list_sessions. _UNCHAINED_ and _CHAINED_. The UNCHAINED session is
a single list operation request. In CHAINED session each subsequent list request
uses the next marker or continuation token from the previous request.

When a CHAINED list is selected, if there is an existing list session for which there is no
outstanding request (free session), that sessions is selected for the next request. If there is no
free session, a new CHAINED list session with will be started with the specified config
parameters.

An UNCHAINED sessions will always have a single request and the session closed after the
request is finished.

The _max_chained_requests_ is the maximum number of list request sent with in a sessions or the
session will end if the end of the bucket listing is reached.

----
  "list_session_config": {
    "selection": "random",
    "choices": [
      {
        "choice": {
          "request_type": "UNCHAINED",
          "start_from_beginning": false,
          "max_chained_requests": 1
        },
        "weight": 1
      },
      {
        "choice": {
          "request_type": "CHAINED",
          "start_from_beginning": true,
          "max_chained_requests": 10
        },
        "weight": 3
      }
    ]
  }
----

_minimum_list_sessions_ property can be specified to indicate the minimum number of active
 list sessions. The default value is 1.

list_prefix has been added to specify the a weighted choice of prefixes. The prefix
can be a maximum of 16 characters.
----
  "prefix": {
    "selection": "random",
    "choices": [
      {
        "choice": {
          "prefix_string": "012",
          "num_chars": 3,
          "use_marker": true
        }
      },
      {
        "choice": {
          "prefix_string": "578",
          "num_chars": 3,
          "use_marker": true
        }
      }
    ]
  }
----

list_delimiter has been added to specify a weighted choice of delimiter characters.
Currently only single character is supported. A special value of "-1" for the delimiter_character
will skip the list_delimiter character in the request.
----
  "list_delimiter": {
    "selection": "random",
    "choices": [
      {
        "choice": {
          "delimiter_character": "a"
        },
        "weight": 1
      },
      {
        "choice": {
          "delimiter_character": "b"
        },
        "weight": 3
      }
    ]
  }
----

==== Operation WriteCopy Configuration ====

WriteCopy operation is used for copying an existing object.  Here is a sample configuration.  The source_object and
source_container properties are specific to this operation. The other properties are properties that belong to all
operations.
The source_container and source_object can be used to generate the names for the source object and the source container.
This option can be used when the object manager is not used.

----
  "write_copy": {
    "weight": 1.0,
    "object": {
      "prefix": "",
      "min_suffix": 0,
      "max_suffix": 9223372036854775807
    },
    "headers": {},
    "parameters": {},
    "body": "none",
    "container": {
      "selection": "random",
      "min_suffix": -1,
      "max_suffix": -1
    },
    "source_container": {
      "prefix": "mycontainer",
      "selection": "random",
      "max_suffix": 5,
      "min_suffix": 0
    },
    "source_object": {
      "selection": "random",
      "prefix": "myobject",
      "max_suffix": 1000,
      "min_suffix": 0
    }
    "sse_c_source": true,
    "sse_c_destination": true
  }
----

==== Operation MultiDelete Configuration ====
MultiDelete operation deletes a set of objects from a given bucket.
multidelete_count is the number of object names for deletion. The default value for 
multidelete_count is 1. multidelete_quiet enables the quiet mode for multidelete. 
The default value for multidelete_quiet is true.
----
  "multi_delete": {
     "weight": 100.00,
     "multidelete_count": 4,
     "multidelete_quiet": true
  }
----

=== Filesize
OG supports one or more filesize distributions for describing desired body lengths of
generated objects. Filesize configuration block can be added to _write_, _overwrite_ and _multipart_write_ 
operations to override global configuration. If multiple filesize distributions are
configured, round robin, random and weighted random selection are supported.

Each file size distribution supports _distribution_, _average_, _average_unit_,
_spread_ and _spread_unit_ keys. *uniform* and *normal* distributions are
supported.

For *uniform* distribution, the shape of the distribution is _average_ +/-
_spread_. For *normal* distribution the shape of the distribution is centered
about _average_, with one standard deviation of _spread_.

Both _average_unit_ and _spread_unit_ support a large number of size units.
See <<Filesize Units>> for details. Units are case insensitive.

.Single Fixed Filesize (10KB) Example
[source, json]
----
"filesize": {"average": 10, "average_unit": "kb"}
----

.Single Filesize Distribution Example
[source, json]
----
"filesize": {
  "distribution": "uniform",
  "average": 10,
  "average_unit": "kb",
  "spread": 2,
  "spread_unit": "kb"
}
----

.Example Multipart Write Operation using its own Filesize Distribution
[source, json]
"multipart_write": {
  "weight": 1.0,
  "object": {"part_size":5242880},
  "filesize": {
    "distribution": "uniform",
    "average": 10,
    "average_unit": "mb",
    "spread": 5,
    "spread_unit": "mb"
  }
}

.Multiple Filesize Distributions Round Robin Example
[source, json]
----
"filesize": {
  "selection": "roundrobin",
  "choices": [
    {
      "distribution": "uniform",
      "average": 10,
      "average_unit": "kb",
      "spread": 2,
      "spread_unit": "kb"
    },
    {
      "distribution": "normal",
      "average": 100,
      "average_unit": "mb"
    }
  ]
}
----
_<<cref1,See note about weights>>_.

.Multiple Filesize Distributions Weighted Random Example
[source, json]
----
"filesize": {
  "selection": "random",
  "choices": [
    {
      "choice": {
        "distribution": "uniform",
        "average": 10,
        "average_unit": "kb",
        "spread": 2,
        "spread_unit": "kb"
      },
      "weight": 8.0
    },
    {
      "choice": {
        "distribution": "normal",
        "average": 100,
        "average_unit": "mb"
      },
      "weight": 1.0
    }
  ]
}
----

_<<cref1,See note about weights>>_.

=== Data
Data determines what type of source data is used for write requests. By
default, OG will generate a small, fixed buffer of random data for every write
request, which is returned repeatedly until the length of the object is
satisfied. Optionally, data can be configured to use all zeroes for object
content. Data is configured via the _data_ key; valid options are *random* and
*zeroes*.

.Zeroes Data Example
[source, json]
----
"data": "zeroes"
----

=== Concurrency
Concurrency configuration allows the OG tool to execute requests in parallel.
There are two types of supported concurrency in OG, *threads* and *ops*.
Concurrency is configured via the _concurrency_ key.

List operations are very resource intensive and excessive concurrency may result
in 503 errors.

[source, json]
----
"concurrency": {}
----

==== Threads Concurrency
Thread testing involves configuring a fixed number of concurrent TCP
connections, each of which will execute requests as quickly as possible. Thread
based testing is good for measuring system capacity.

Thread testing supports _count_, _rampup_ and _rampup_unit_ keys. Rampup
allows a thread based test to build up to a steady connection rate over a
configurable period of time.

.Single Thread Example
[source, json]
----
"concurrency": {
  "type": "threads",
  "count": 1
}
----

.Multiple Threads Example
[source, json]
----
"concurrency": {
  "type": "threads",
  "count": 10
}
----

.Multiple Threads With Rampup Example
[source, json]
----
"concurrency": {
  "type": "threads",
  "count": 10,
  "rampup": 60,
  "rampup_unit": "seconds"
}
----

See <<Time Units>> for supported time units.

==== Request Rate Concurrency
Request Rate concurrency (ops) testing involves configuring a desired request
rate at which to send requests. A variable number of TCP connections will be
used to satisfy the configured rate. Request rate testing is good for measuring
system latency.

Request Rate testing supports _count_, _unit_, _rampup_ and _rampup_unit_
keys. Rampup allows an ops based test to build up to a steady request rate
over a configurable period of time.

.Request Rate (100 op/s) Example
[source, json]
----
"concurrency": {
  "type": "ops",
  "count": 100,
  "unit": "seconds"
}
----

.Request Rate (500 op/minute) With Rampup Example
[source, json]
----
"concurrency": {
  "type": "ops",
  "count": 500,
  "unit": "minutes",
  "rampup": 60,
  "rampup_unit": "seconds"
}
----

See <<Time Units>> for supported time units.

=== Stopping Conditions
Stopping conditions determine when a running OG instance should stop. By
default, OG will run indefinitely until a user stops it via a ctrl-c or
equivalent signal. Stopping conditions are configured via the
_stopping_conditions_ key:

[source, json]
----
"stopping_conditions": {}
----

==== Operations
The operations stopping condition causes OG to stop when a threshold number
of operations has completed. Operations is configured via the _operations_
key.

NOTE: Since Multipart Write is a sequence of multiple operations, the operation count does
not map directly to the number of Multipart Write sequences, but the total number of
operations for all sequences. For example, a single Multipart Write of an object consisting
of an Initiate, Part, Part, and Complete would count as 4 operations towards the
stopping condition

.Stop after 100 Operations Example
[source, json]
----
"stopping_conditions": {
  "operations": 100
}
----

==== Runtime
The runtime stopping condition causes OG to stop when a threshold period of
time has elapsed. Runtime is configured via the _runtime_ and _runtime_unit_
keys.

.Stop after 3.5 Hours Example
[source, json]
----
"stopping_conditions": {
  "runtime": 3.5,
  "runtime_unit": "hours"
}
----

See <<Time Units>> for supported time units.

==== Status Codes
The status codes stopping condition causes OG to stop when a threshold number
of status codes of a given number have been received.

.Stop After One Hundred "200" Status Codes Received Example
[source, json]
----
"stopping_conditions": {
  "status_codes": {
    "200": 100
  }
}
----

.Stop After Any "404", "500", or "503" Status Codes Received Example
[source, json]
----
"stopping_conditions": {
  "status_codes": {
    "404": 1,
    "500": 1,
    "503": 1
  }
}
----

NOTE: OG uses a special reserved status code *599* to indicate a failed or
aborted request. This special status code can also be used as a status code
stopping condition.

=== Secure HTTP connections
Secure http connections can be used with HTTPS scheme with SSL/TLS for OG operations.
To do this the following configuration needs to be set in addition to other
properties.

- https scheme
- trust self signed certificate if needed in client configuration
- Optionally specify a list of cipher algorithms to use in client configuration


.sample configuration
[source, json]
----
{
  "scheme": "https",
  "client": {
    "cipher_suites": ["TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"],
    "trust_self_signed_certificates": true,
  }
}
----

=== Object Management
OG tracks the state of objects written to containers. The OG object manager
writes metadata about the objects into a set of binary files called "object
files". Object management is configured via the _object_manager_ key. The
location to store object files is configured via _object_file_location_ and
_object_file_name_ keys.

_object_file_location_ specifies which directory the object file(s) should be
written to. The default location is in the *object* sub-directory of the directory where
OG is launched from.

_object_file_name_ specifies a file prefix to use when writing object files.
Every object file that is written will contain a numeric component to the file
name. If _object_file_name_ was configured as *my_object* and three files were
written over the course of an OG test, the resulting object file names would be
*my_object0.object*, *my_object1.object*, and *my_object2.object*, respectively.

If _object_file_name_ is not specified, a default name of the following form is
used:

[source, bash]
----
<container prefix>-<api>
----

.Object Manager Example
[source, json]
----
"object_manager": {
  "object_file_location": "/var/log/og-objects",
  "object_file_name": "my_objects"
}
----


With release 1.4.0, the binary file format for object files is changed. The binary file
contains a version header VERSION:<major_version><minor_version>.  Two additional fields
are also tracked - number of legalholds on the object and the retention time of the
object.

WARNING: Object files are not thread safe. Multiple instances of the OG tool
should not share the same set of object files. Attempting to do so will result
in object file corruption and/or a loss of object file metadata.

=== Advanced Configuration
OG supports several additional advanced configuration options that enable its
use for more complex scenarios, edge case testing and defect reproduction.

CAUTION: It is recommended to avoid modifying any of the below configuration
options unless a particular advanced configuration is required for testing.

==== URI Root
OG supports configuring the root URI path at which the object storage API is
located. URI Root is configured via the _uri_root_ key and the default value
is to root the configured Storage API at _/<api>/_. For example, request URIs
for S3 requests using the default _uri_root_ would take the form:

[source, bash]
----
/s3/<container>/<object>
----

.URI Root Alternate Example
[source, json]
----
"uri_root": "/"
----

==== Virtual Host
Some Object Storage implementations support virtual host addressing, which is
a way to express containers as virtual sub-domains. OG supports this
configuration via the _virtual_host_ key. The default configuration is false,
which means that object storage request URIs are of the form:

[source, bash]
----
<host>://<uri_root>/<container>/<object>
----

With virtual host set to true, request URIs are of the form:

[source, json]
----
<container>.<host>://<object>
----

NOTE: When virtual host is enabled, the _uri_root_ configuration is ignored.

==== Shutdown Behavior
By default, when OG shuts down it aborts all in progress requests in order to
ensure that the tool terminates in a reasonable time. For some use cases, it is
valuable to configure the tool to allow in progress requests to complete prior
to termination. This option is configured via the _shutdown_immediate_ key.
If the option is set to false, OG waits for requests to complete until shutdown
timeout is reached. If there are requests that are not complete by this point,
OG will return an error code 3 and report/log the number of aborted requests.
Shutdown timeout in seconds is set by _shutdown_timeout_ key with default of 3600.

.Immediate Shutdown Example
[source, json]
----
"shutdown_immediate": true
----

.Graceful Shutdown Example
[source, json]
----
"shutdown_immediate": false,
"shutdown_timeout": 30
----

==== Stats Logging Interval
OG dumps the stats periodically in the console as well as og log. The interval period
 can be configured with _stats_log_interval_ key. The default value is -1, which disables
 interval stats. *The stats_log_interval must be atleast 10 seconds*.

The interval stats are logged on the console as well as og_interval.json file.

==== Octal naming mode
A new mode for generating object names only from the octal character set is introduced.
This option is configured via the _octal_naming_mode_ key. The default value is false.
When this property is true, the object names will have only characters from [0-7]. When
it is false, the object names have the hex character set [0-f].
This is introduced for flexibility to test listing with prefixes and delimiters. For example,
the object names could be octal character set and delimiters can be be hex character set.


==== Client Behavior
OG supports a large number of TCP and HTTP tuning parameters which affect
client execution behavior. For a complete list, see <<Client Configuration>>.

==== Object Management Behavior
OG supports several configuration options for modifying object management
behavior. These keys are for development use only and should not be modified
for production testing. See <<Object Manager Configuration>>.


==== Environment Variables
OG exposes several environment variables which can be used to modify functional
and performance characteristics of the tool. They include:

|===
|Environment Variable|Description

|OG_MEMORY
|Maximum JVM heap size, in megabytes. Default is 2048 (2GB)

|OG_ULIMIT
|Maximum open file handles. Default is 4096. Useful to increase if testing
concurrency larger than 4000 threads (not recommended).

|OG_TEST_PATH
|Configure a custom test log path

|OG_GC_LOG
|Configure a custom gc log name. The gc log will be logged relative to
OG_TEST_PATH
|===

==== Object Management Script
OG also includes an _object-file_ shell script, which is used for reading and
writing object files. A description of the usage of this script is outside the
scope of this guide, and the script itself is rarely useful other than for
development purposes.

With release 1.4.0, the object-file is enhanced to support both pre-1.4.0 object files (1.0) and
1.4.0 object files (v2.0).


== Results
For each OG test that is run, a test results directory is created with the
starting timestamp of the test.

[source, bash]
----
~$ tree log/
log/
└── 2015-06-17_23.56.32 // <1>
    ├── gc.log // <2>
    ├── og.json // <3>
    ├── og.log // <4>
    ├── request.log // <5>
    └── summary.json // <6>
----
<1> Parent directory for the test run
<2> JVM gc.log for this test
<3> Serialized og.json, including default values; useful for config auditing
<4> Application logs
<5> Per-request log, including http details
<6> Summary statistics

=== Request Log
The OG request.log provides detailed per-request data for every request that is
executed during a test. Each line in request.log is a json object which
contains details for an individual request.

.Sample Line From request.log
[source, json, subs="attributes"]
----
{
  "operation": "WRITE",
  "type": "http",
  "remote_address": "loadbalancer01.example.com",
  "timestamp_start": "1453481170147",
  "timestamp_finish": "1453481170197",
  "time_start": "22/Jan/2016:10:46:10 -0600",
  "time_finish": "22/Jan/2016:10:46:10 -0600",
  "request_method": "PUT",
  "request_uri": "/s3/test/8ca1dc1cd5a04bbdb10bd9b20e6516250000",
  "object_id": "8ca1dc1cd5a04bbdb10bd9b20e6516250000",
  "status": 200,
  "request_length": "10",
  "user_agent": "og-{display-version}",
  "request_latency": "50",
  "client_request_id": "0",
  "stat": {
    "request_content": 0.03,
    "close_latency": 13.58,
    "ttfb": 48.86,
    "response_content": 0.24,
    "total": 50.03
  },
  "object_length": "10",
  "object_name": "8ca1dc1cd5a04bbdb10bd9b20e6516250000"
}
----

For a complete description of all fields, see <<Request Log Fields>>.

=== Summary Log
The OG summary.json provides a high level summary of the results of a test run.

.Sample summary.json
[source, json]
----
{
  "exit_code": 0,
  "exit_messages": [
    "Test exited normally"
  ],
  "requests_aborted": 0,
  "timestamp_start": 1452558285641,
  "timestamp_finish": 1452558287184,
  "runtime": 1.543,
  "operations": 11,
  "write": {
    "operations": 11,
    "bytes": 11000,
    "status_codes": {
      "200": 11
    }
  },
  "read": {
    "operations": 0,
    "bytes": 0,
    "status_codes": {}
  },
  "delete": {
    "operations": 0,
    "bytes": 0,
    "status_codes": {}
  }
}
----

=== Interval Log
The og_interval.json log file contains the stats for each interval. The interval stats is formatted
as json object on each line.

.Sample interval stats record
----
{
  "timestamp_start": 1547048037538,
  "timestamp_finish": 1547048048556,
  "runtime": 11.018,
  "operations": 90,
  "write": {
    "operations": 90,
    "bytes": 274000,
    "average_latency": 109.76,
    "status_codes": {
      "200": 90
    }
  },
  "read": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "delete": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "metadata": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "overwrite": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "list": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "container_list": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "container_create": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "multipart_write_initiate": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "multipart_write_part": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "multipart_write_complete": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "multipart_write_abort": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "write_copy": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "write_legal_hold": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "read_legal_hold": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "delete_legal_hold": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "extend_retention": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "object_restore": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "put_container_lifecycle": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "get_container_lifecycle": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "delete_container_lifecycle": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "put_container_protection": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  },
  "get_container_protection": {
    "operations": 0,
    "bytes": 0,
    "average_latency": 0,
    "status_codes": {}
  }
}
----

== Examples
The following examples describe a test scenario and the resulting configuration
needed to execute the test. Each example is fully functional, requiring minimal
modification to run. For a detailed explanation of all available configuration
options, see <<Configuration>>.

=== Simple Capacity Test
.Test Scenario
Execute an *S3*, *100% write* capacity test with *10 threads*. The test should
write *10 million objects* and all objects should be *5 megabytes* in size.

.OG Configuration
[source, json]
----
include::{sampledir}/simple-capacity.json[]
----

=== Simple Latency Test, Mixed Operations and Filesize
.Test Scenario
Execute an *SOH*, *50%/50% write/read mix* latency test with
*10 requests per second* against a Cleversafe dsNet. The test should write
*3 million objects* and a mix of file sizes should be used. *80%* of written
files should be a *fixed 5KB*. *20%* of files should be a *uniform
distribution* between *8KB and 12KB*. Object manager object files should be
stored at */tmp/objects* with a prefix of *soh_objects*.

.OG Configuration
[source, json]
----
include::{sampledir}/simple-latency.json[]
----

=== AWSv2 Authentication Test
.Test Scenario
Execute an *S3*, *100% write* capacity test with *10 threads*. The test should
use AWSv2 authentication with *AKIAIOSFODNN74SFNMK* for the access key and
*nJalrUUFklNEMI/K7MDENG/gPwRfiCYXY73DER* for the secret key. The test should
stop when *one thousand* successful *(200)* or *any* unsuccessful *(500, 503)*
response codes have been received, whichever comes first.

Object names should be written randomly with names in the range *my_object0* to
*my_object10000*.

.OG Configuration
[source, json]
----
include::{sampledir}/awsv2.json[]
----

== FAQ

===== Q: What does _com.google.gson.stream.MalformedJsonException_ mean?

A: _MalformedJsonException_ means that the json configuration file that has
been passed to OG has a syntax error. Common json syntax errors include missing
or extra commas, curly braces and square braces.

When a malformed configuration file is passed to OG, An error message will be
printed to the console:

[source, bash]
----
$ ./og conf/sample/simple-s3.json
-------------------------------------------------------------------------------
Object Generator (1.0.0-SNAPSHOT)
-------------------------------------------------------------------------------
Configuring...
Test Error. See og.log for details
com.google.gson.stream.MalformedJsonException: Unterminated object at line 4 column 2 path $.api
----

In the above example, the error message indicates that there is likely a
missing comma on line 4 of the configuration file.

===== Q: I see several _SocketException_ and _CancellationException_ messages in og.log, should I be concerned?

A: These exceptions are typically either a result of a closed TCP connection
or OG shutdown. If the exceptions correlate with expected shutdown of the OG
tool then they are likely of no concern. If an exception is logged in the
middle of a test, it may be worth investigating. Closed sockets are usually due
to either a network problem, or an overloaded system under test.

===== Q: I am attempting to run a write/read/delete mix test but it keeps stopping immediately. Why?

A: When running a mixed operation test in OG, the choice of next operation is
determined randomly based on the configured weights of each operation. If no
previous test has been run to populate a container with objects, and a mixed
operation test is executed, there is a chance that a read or delete operation
request will not have any previously written object to draw from. This will
cause a perceived "early termination" of the tool.

To prevent early termination of OG, run a write operations only workload to
populate container(s) with a sufficient number of objects prior to running
mixed operation tests.

== Appendix

=== Configuration Reference

==== General Configuration
|===
|Parameter|Type|Required|Default

|host
|String or Complex
|Yes
|None

|port
|Integer
|No
|80

|api
|Enum ("s3", "openstack", "soh", "webdav")
|Yes
|None

|uri_root
|String
|No
|"/<api>/"

|container
|String or Complex
|Yes
|None

|headers
|Object
|No
|{}

|write
|Complex
|Yes
|None

|read
|Complex
|Yes
|None

|delete
|Complex
|Yes
|None

|filesize
|Complex
|No
|None

|data
|Enum ("random", "zeroes")
|No
|"random"

|concurrency
|Complex
|Yes
|None

|authentication
|Complex
|No
|None

|client
|Complex
|No
|None

|stopping_conditions
|Complex
|No
|None

|object_manager
|Complex
|No
|None

|shutdown_immediate
|Boolean
|No
|true

|shutdown_timeout
|Integer (seconds)
|No
|3600

|stats_log_interval
|Integer (seconds)
|No
|-1

|octal_naming_mode
|Boolean
|No
|true

|===

[[operation_configuration]]
==== Operation Configuration
|===
|Parameter|Type|Required|Default

|host
|String or Complex
|No
|None

|object
|Complex
|No
|None

|headers
|Object
|No
|{}

|weight
|Decimal
|No
|0.0

|sse_c_source
|boolean
|No
|false

|sse_c_destination
|boolean
|No
|false

|Retention
|Complex
|No
|None

|LegalHold
|Complex
|No
|None

|content_md5
|boolean
|No
|false

|===

==== Object Configuration
Object keys are only required if the object block is present. The object block
itself is optional.
|===
|Parameter|Type|Required|Default

|prefix
|String
|No
|""

|selection
|Enum ("random", "roundrobin")
|Yes
|None

|min_suffix
|Integer
|No
|0

|max_suffix
|Integer
|No
|9223372036854775807

|part_size
|Long
|No
|5242880 bytes
|===

==== Filesize Configuration
|===
|Parameter|Type|Required|Default

|distribution
|Enum ("uniform", "normal")
|No
|"uniform"

|average
|Decimal
|Yes
|None

|average_unit
|Enum (see <<Filesize Units>>)
|No
|"bytes"

|spread
|Decimal
|No
|0.0

|spread_unit
|Enum (see <<Filesize Units>>)
|No
|"bytes"

|weight
|Decimal
|No
|1.0
|===

==== Concurrency Configuration
|===
|Parameter|Type|Required|Default

|type
|Enum ("threads", "ops")
|Yes
|None

|count
|Decimal
|Yes
|None

|unit
|Enum (see <<Time Units>>)
|No
|"seconds"

|rampup
|Decimal
|No
|0.0

|rampup_unit
|Enum (see <<Time Units>>)
|No
|"seconds"
|===

==== Authentication Configuration
Authentication keys are only required if the authentication block is present.
The authentication block itself is optional, and will default to anonymous
authentication if absent.
|===
|Parameter|Type|Required|Default

|type
|Enum ("basic", "awsv2", "awsv4", "keystone")
|Yes
|None

|username
|String
|Yes
|None

|password
|String
|Yes
|None

|credential_source
|String ("file" or "config")
|Yes
|None

|credential_file
|String
|Yes
|None

|account
|String
|Yes
|None


|aws_chunked
|Boolean
|No
|false; S3 only

|aws_cache_size
|Integer
|No
|0; disabled. S3 only
|===

==== Client Configuration
|===
|Parameter|Type|Required|Default

|connect_timeout
|Integer
|No
|0; in milliseconds

|so_timeout
|Integer
|No
|0; in milliseconds

|so_reuse_address
|Boolean
|No
|false

|so_linger
|Integer
|No
|-1

|so_keep_alive
|Boolean
|No
|true

|tcp_no_delay
|Boolean
|No
|true

|so_snd_buf
|Integer
|No
|0; "platform default"

|so_rcv_buf
|Integer
|No
|0; "platform default"

|persistent_connections
|Boolean
|No
|true

|validate_after_inactivity
|Integer
|No
|10000; in milliseconds

|max_idle_time
|Integer
|No
|60000; in milliseconds

|chunked_encoding
|Boolean
|No
|false

|expect_continue
|Boolean
|No
|false

|wait_for_continue
|Integer
|No
|3000

|retry_count
|Integer
|No
|0

|request_sent_retry
|Boolean
|No
|true

|protocols
|List of String
|No
|None

|cipher_suites
|List of String
|No
|None

|key_store
|String
|No
|None

|key_store_password
|String
|No
|None

|key_password
|String
|No
|None

|trust_store
|String
|No
|None

|trust_store_password
|String
|No
|None

|trust_self_signed_certificates
|Boolean
|No
|false

|dns_cache_ttl
|Integer
|No
|60

|dns_cache_negative_ttl
|Integer
|No
|10

|write_throughput
|Integer
|No
|0; in bytes per second

|read_throughput
|Integer
|No
|0; in bytes per second
|===

==== Stopping Conditions Configuration
|===
|Parameter|Type|Required|Default

|operations
|Integer
|No
|None

|runtime
|Decimal
|No
|None

|runtime_unit
|Enum (see <<Time Units>>)
|No
|"seconds"

|status_codes
|Object
|No
|{}
|===



==== Failing Conditions Configuration
|===
|Parameter|Type|Required|Default

|operations
|Integer
|No
|None

|runtime
|Decimal
|No
|None

|runtime_unit
|Enum (see <<Time Units>>)
|No
|"seconds"

|concurrent_requests
|Integer
|No
|2000

|status_codes
|Object
|No
|{}
|===

==== Object Manager Configuration
|===
|Parameter|Type|Required|Default

|object_file_location
|String
|No
|"./object"

|object_file_name
|String
|No
|"<container>-<api>"

|object_file_max_size
|Integer; in bytes
|No
|100000000 // 100mb

|object_file_persist_frequency
|Integer; in seconds
|No
|1800 // 30 minutes

|object_file_index
|Integer
|No
|None; advanced option
|===

=== Request Log Fields
|===
|Field|Type|Required|Notes

|operation
|String
|Yes
|Write, Overwrite, Read, Metadata, Delete, List

|type
|String
|Yes
|Always "http"

|remote_address
|String
|Yes
|Hostname or IP address

|user
|String
|No
|Only available if authentication is configured

|timestamp_start
|Integer
|Yes
|Unix time, in milliseconds

|timestamp_finish
|Integer
|Yes
|Unix time, in milliseconds

|time_start
|String
|Yes
|Format is: "dd/MMM/yyyy:HH:mm:ss Z"

|time_finish
|String
|Yes
|Format is: "dd/MMM/yyyy:HH:mm:ss Z"

|request_method
|Enum ("PUT", "GET", "HEAD", "DELETE")
|Yes
|

|request_uri
|String
|Yes
|

|object_id
|String
|Yes
|Object name used for the request. For SOH write requests, the returned object
name

|status
|Integer
|Yes
|HTTP status code, or *599* for failed requests

|request_length
|Integer
|No
|Only available for write requests

|response_length
|Integer
|No
|Only available for read requests

|user_agent
|String
|No
|

|request_latency
|Integer
|Yes
|timestamp_finish - timestamp_start, in milliseconds

|client_request_id
|String
|Yes
|unique auto-generated id for every request

|request_id
|String
|No
|Cleversafe unique request id. Only available when testing against a
Cleversafe dsNet

|stat
|Object
|Yes
|

|stat.request_content
|Decimal
|No
|Time to send request content, in milliseconds. Only available for write
requests

|stat.close_latency
|Decimal
|No
|Time to complete request after request content has been sent, in milliseconds.
Only available for write requests

|stat.ttfb
|Decimal
|No
|Time between the beginning of a request and the first byte received of the
response content, in milliseconds. Only available for read requests

|stat.response_content
|Decimal
|No
|Time to receive response content, in milliseconds. Only available for read
requests

|stat.total
|Decimal
|Yes
|Total duration

|object_length
|Integer
|No
|Equivalent to _request_length_

|object_name
|String
|Yes
|Equivalent to _object_id_
|===

=== Filesize Units
All units are case insensitive.
|===
|Input|Unit

|"b", "byte", "bytes"
|bytes

|"kb", "kilobyte", "kilobytes"
|kilobytes

|"kib", "kibibyte", "kibibytes"
|kibibytes

|"mb", "megabyte", "megabytes"
|megabytes

|"mib", "mebibyte", "mebibytes"
|mebibytes

|"gb", "gigabyte", "gigabytes"
|gigabytes

|"gib", "gibibyte", "gibibytes"
|gibibytes

|"tb", "terabyte", "terabytes"
|terabytes

|"tib", "tebibyte", "tebibytes"
|tebibytes

|"pb", "petabyte", "petabytes"
|petabytes

|"pib", "pebibyte", "pebibytes"
|pebibytes
|===

=== Time Units
All units are case insensitive.
|===
|Input|Unit

|"ns", "nano", "nanosec", "nanosecs", "nanosecond", "nanoseconds"
|nanoseconds

|"micro", "micros", "microsec", "microsecs", "microsecond", "microseconds"
|microseconds

|"ms", "milli", "millis", "millisec", "millisecs", "millisecond", "milliseconds"
|milliseconds

|"s", "sec", "secs", "second", "seconds"
|seconds

|"m", "min", "mins", "minute", "minutes"
|minutes

|"h", "hr", "hrs", "hour", "hours"
|hours

|"d", "day", "days"
|days
|===

[[credential_file_format]]
=== Credential File Format
The Credential file is needed if the credential source is to set to file. Credential file contains the credential
information necessary for invoking object storage api and authentication.

The older format of the credential file contains a comma separated s3 access key, secret key pair.

With this release of OG, it expects an updated format of the credential file. The credential file contains the account
information (account name, list of containers), credential information like basic authentication username, password,
aws access key and secret key, keystone token, container list.

Each line in the new credential file is a json representation of the account information. The information depends on the API,
type of authentication used.

Based on the authentication type, relevant properties will be used - basic_auth_username, basic_auth_password for basic
authentication, keystone for keystone token based authentication, s3 credentials for awsv2 and awsv4, IAM token for
IAM authentication, etc.

OpenStack with swift on Stass dsnet implementation requires an account name and the container name in the API. Swift
API version 1 is used in OG. In case of vault mode, account name is not needed. API is called
with account "dummyaccount" for vault mode.

Credentials for OpenStack API generated by perf-runner:
[source, json]
----
{
    "api": "openstack",
    "account_name": "osaccount101",
    "basic_auth_password": "password",
    "project_name": "osaccount101",
    "basic_auth_username": "sos_user",
    "keystone_username": "keystone-user",
    "domain_name": "test-domain",
    "token": "9063fce56ff745d1b50ffbb46abbcbb6",
    "keystone_password": "password",
    "manager_username": "keystone-manager-user",
    "manager_password": "password",
    "containers": ["osc201", "osc202", "osc203"]
}
----

Credentials for S3 API with AWS authentication generated by perf-runner:
[source, json]
----
{
    "api": "s3",
    "account_name": "s3account1",
    "access_key": "jey3MxWQUE9YIaBUtXD1",
    "secret_key": "GDzvc103T8kM8bvZ5B8UYpFWB9QSJEoasaHfEuot",
    "containers": ["s3c7", "s3c8", "s3c9"]
}
----

Credentials for S3 API with IAM authentication generated by perf-runner:
[source, json]
----
{
    "api": "s3",
    "account_name": "storage_account",
    "iam_token": "Bearer eyJra...",
    "containers": ["iamc1", "iamc2", "iamc3"]
}
----
